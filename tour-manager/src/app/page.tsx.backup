"use client";

import { useEffect, useState, useRef } from "react";
import { useSession, signOut } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Product, CartItem, PaymentMethod, Sale, SyncStatus } from "@/types";
import {
  getProducts,
  saveProducts,
  addProduct as addProductToDB,
  deleteProduct as deleteProductFromDB,
  saveSale,
  getSales,
  getUnsyncedSales,
  markSaleAsSynced,
  deleteSyncedSales,
} from "@/lib/db";
import { DEFAULT_PRODUCTS } from "@/lib/defaultProducts";
import POSInterface from "@/components/POSInterface";
import ProductManager from "@/components/ProductManager";
import Settings from "@/components/Settings";
import Analytics from "@/components/Analytics";
import SyncStatusBar from "@/components/SyncStatusBar";
import OfflineIndicator from "@/components/OfflineIndicator";
import Toast, { ToastType } from "@/components/Toast";
import {
  Cog6ToothIcon,
  ShoppingBagIcon,
  ArchiveBoxIcon,
  ChartBarIcon,
  ArrowRightOnRectangleIcon,
} from "@heroicons/react/24/outline";
import { useTheme } from "@/components/ThemeProvider";

export default function Home() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const initializingRef = useRef(false); // Prevent multiple initializations
  const [products, setProducts] = useState<Product[]>([]);
  const [categoryOrder, setCategoryOrder] = useState<string[]>([]); // Add category order state
  const [activeTab, setActiveTab] = useState<
    "pos" | "setup" | "analytics" | "settings"
  >("pos");
  const [syncStatus, setSyncStatus] = useState<SyncStatus>({
    lastSyncTime: null,
    pendingSales: 0,
    totalSales: 0,
    isSyncing: false,
    pendingProductSync: false,
  });
  const [isInitialized, setIsInitialized] = useState(false);
  const [isInitializingSheets, setIsInitializingSheets] = useState(false);
  const [loadedFromSheets, setLoadedFromSheets] = useState(false); // Track if products were loaded from Sheets
  const [productsChanged, setProductsChanged] = useState(false); // Track if products actually changed
  const [toast, setToast] = useState<{
    message: string;
    type: ToastType;
  } | null>(null);

  // Get theme context to apply saved theme on load
  const { setTheme } = useTheme();

  // Handle authentication redirect
  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/auth/signin");
    }
  }, [status, router]);

  // Monitor session for token refresh errors and auto-logout
  useEffect(() => {
    if (session?.error === "RefreshAccessTokenError") {
      console.error("Token refresh failed. Logging out...");
      setToast({
        message: "Your session has expired. Please sign in again.",
        type: "error",
      });
      // Sign out after a short delay to show the toast
      setTimeout(() => {
        signOut({ callbackUrl: "/auth/signin" });
      }, 2000);
    }
  }, [session]);

  // Load theme from settings on initialization
  useEffect(() => {
    const loadThemeFromSettings = async () => {
      const spreadsheetId = localStorage.getItem("salesSheetId");
      if (!spreadsheetId) return;

      try {
        const response = await fetch("/api/sheets/settings/load", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ spreadsheetId }),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.theme) {
            setTheme(data.theme);
          }
        }
      } catch (error) {
        console.error("Failed to load theme:", error);
      }
    };

    if (session && isInitialized) {
      loadThemeFromSettings();
    }
  }, [session, isInitialized, setTheme]);

  useEffect(() => {
    if (session && !isInitialized && !initializingRef.current) {
      initializingRef.current = true;
      initializeApp();
    }
  }, [session, isInitialized]);

  useEffect(() => {
    if (isInitialized) {
      updateSyncStatus();
      const interval = setInterval(updateSyncStatus, 5000);
      return () => clearInterval(interval);
    }
  }, [isInitialized]);

  // Auto-sync on page load/refresh after initialization
  useEffect(() => {
    if (isInitialized && navigator.onLine) {
      const autoSync = async () => {
        console.log("ðŸ”„ Auto-syncing on page load...");

        const unsyncedSales = await getUnsyncedSales();
        const hasUnsyncedProducts = syncStatus.pendingProductSync;

        // Build toast message based on what happened
        const messageParts: string[] = [];

        // If products were loaded from Sheets AND they changed, mention it
        if (loadedFromSheets && productsChanged) {
          messageParts.push("Loaded latest products");
        }

        // Sync any local changes
        if (unsyncedSales.length > 0 || hasUnsyncedProducts) {
          const syncParts: string[] = [];

          if (unsyncedSales.length > 0) {
            await syncSales();
            syncParts.push(
              `${unsyncedSales.length} sale${
                unsyncedSales.length > 1 ? "s" : ""
              }`
            );
          }

          if (hasUnsyncedProducts) {
            await syncProductsToSheet();
            syncParts.push("products");
          }

          if (syncParts.length > 0) {
            messageParts.push(`synced ${syncParts.join(" and ")}`);
          }
        }

        // Show toast if there's something to report
        if (messageParts.length > 0) {
          // Capitalize first letter
          const message = messageParts.join(" and ");
          const formattedMessage =
            message.charAt(0).toUpperCase() + message.slice(1);

          setToast({
            message: formattedMessage,
            type: "success",
          });
        }
      };

      // Small delay to let the app finish loading
      const timer = setTimeout(autoSync, 1000);
      return () => clearTimeout(timer);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isInitialized]);

  // Auto-sync when coming back online
  useEffect(() => {
    const handleOnline = async () => {
      console.log("ðŸ“¶ Network connection restored - auto-syncing...");

      // Sync sales if needed
      const unsyncedSales = await getUnsyncedSales();
      if (unsyncedSales.length > 0) {
        setTimeout(() => {
          syncSales();
        }, 1000);
      }

      // Sync products if needed
      if (syncStatus.pendingProductSync) {
        setTimeout(() => {
          syncProductsToSheet();
        }, 1500);
      }
    };

    globalThis.addEventListener("online", handleOnline);
    return () => globalThis.removeEventListener("online", handleOnline);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Helper function to detect if products have changed
  const detectProductChanges = (
    oldProducts: Product[],
    newProducts: Product[]
  ): boolean => {
    // If counts differ, they've changed
    if (oldProducts.length !== newProducts.length) {
      return true;
    }

    // If no old products (first load), consider it changed
    if (oldProducts.length === 0) {
      return newProducts.length > 0;
    }

    // Create a simple fingerprint by sorting IDs and comparing
    const oldFingerprint = [...oldProducts]
      .map((p) => p.id)
      .sort((a, b) => a.localeCompare(b))
      .join(",");
    const newFingerprint = [...newProducts]
      .map((p) => p.id)
      .sort((a, b) => a.localeCompare(b))
      .join(",");

    // If IDs changed, products changed
    if (oldFingerprint !== newFingerprint) {
      return true;
    }

    // Check if any product's key properties changed
    // Create a more detailed fingerprint including name, price, and inventory
    const sortedOldProducts = [...oldProducts].sort((a, b) =>
      a.id.localeCompare(b.id)
    );
    const sortedNewProducts = [...newProducts].sort((a, b) =>
      a.id.localeCompare(b.id)
    );

    const oldDetailedFingerprint = sortedOldProducts
      .map(
        (p) =>
          `${p.id}:${p.name}:${p.price}:${JSON.stringify(p.inventory || {})}`
      )
      .join("|");

    const newDetailedFingerprint = sortedNewProducts
      .map(
        (p) =>
          `${p.id}:${p.name}:${p.price}:${JSON.stringify(p.inventory || {})}`
      )
      .join("|");

    return oldDetailedFingerprint !== newDetailedFingerprint;
  };

  const initializeApp = async () => {
    try {
      // Check for force-new parameter to bypass cached IDs (for testing)
      const urlParams = new URLSearchParams(window.location.search);
      const forceNew = urlParams.has("force-new");

      if (forceNew) {
        console.log("ðŸ†• Force-new parameter detected - clearing cached IDs");
        localStorage.removeItem("productsSheetId");
        localStorage.removeItem("salesSheetId");
        // Remove the parameter from URL
        window.history.replaceState({}, "", window.location.pathname);
      }

      // Check if user has sheet IDs stored locally
      let storedProductsSheetId = localStorage.getItem("productsSheetId");
      let storedSalesSheetId = localStorage.getItem("salesSheetId");

      // If no local IDs, search for existing spreadsheet in Google Drive
      if (!storedProductsSheetId || !storedSalesSheetId) {
        console.log("ðŸ” No local sheet IDs found, searching Google Drive...");
        try {
          const findResponse = await fetch("/api/sheets/find");
          console.log("ðŸ“¡ Search response status:", findResponse.status);

          if (findResponse.ok) {
            const findData = await findResponse.json();
            console.log("ðŸ“„ Search result:", findData);

            if (findData.found) {
              // Found existing spreadsheet - use it
              localStorage.setItem("productsSheetId", findData.spreadsheetId);
              localStorage.setItem("salesSheetId", findData.spreadsheetId);
              storedProductsSheetId = findData.spreadsheetId;
              storedSalesSheetId = findData.spreadsheetId;
              console.log(
                "âœ… Found existing Merch Table spreadsheet!",
                findData.spreadsheetId
              );
            } else {
              console.log(
                "â„¹ï¸ No existing spreadsheet found, will create new one"
              );
            }
          } else {
            const errorText = await findResponse.text();
            console.error("âŒ Search request failed:", errorText);
          }
        } catch (error) {
          console.error("âŒ Error searching for existing spreadsheet:", error);
        }
      } else {
        console.log("âœ… Using cached sheet IDs:", {
          storedProductsSheetId,
          storedSalesSheetId,
        });
      }

      // If still no sheet IDs, create new spreadsheet
      if (!storedProductsSheetId || !storedSalesSheetId) {
        console.log("ðŸ“ Creating new spreadsheet...");
        setIsInitializingSheets(true);
        try {
          const response = await fetch("/api/sheets/initialize", {
            method: "POST",
          });

          console.log("ðŸ“¡ Create response status:", response.status);

          if (response.ok) {
            const data = await response.json();
            console.log("ðŸ“„ Create result:", data);
            localStorage.setItem("productsSheetId", data.productsSheetId);
            localStorage.setItem("salesSheetId", data.salesSheetId);
            if (data.sheetName) {
              localStorage.setItem("salesSheetName", data.sheetName);
            }
            console.log(
              "âœ… Google Sheets created successfully!",
              data.productsSheetId
            );
          } else {
            const errorText = await response.text();
            console.error("âŒ Failed to initialize sheets:", errorText);
          }
        } catch (error) {
          console.error("âŒ Error initializing sheets:", error);
        } finally {
          setIsInitializingSheets(false);
        }
      }

      // Load products - try from Google Sheets first, then IndexedDB, then defaults
      let loadedProducts: Product[] = [];
      let productsLoadedFromSheets = false;

      // Get current products from IndexedDB to compare for changes
      const currentProducts = await getProducts();

      // If we have a sheet ID, try loading products from Google Sheets
      if (storedProductsSheetId) {
        try {
          console.log("ðŸ“¥ Loading products from Google Sheets...");

          // Add timeout to prevent hanging
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

          const response = await fetch("/api/sheets/load-products", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ productsSheetId: storedProductsSheetId }),
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            const data = await response.json();
            if (data.products && data.products.length > 0) {
              loadedProducts = data.products;
              await saveProducts(loadedProducts); // Save to IndexedDB
              productsLoadedFromSheets = true;
              console.log(
                "âœ… Loaded",
                loadedProducts.length,
                "products from Google Sheets"
              );
            } else {
              console.log("â„¹ï¸ No products found in Google Sheets");
            }
          } else {
            console.error("âŒ Load products response not OK:", response.status);
          }
        } catch (error) {
          if (error instanceof Error && error.name === "AbortError") {
            console.error("âŒ Load products timed out after 10 seconds");
          } else {
            console.error("âŒ Failed to load from Google Sheets:", error);
          }
        }
      }

      // If no products from sheets, try IndexedDB
      if (loadedProducts.length === 0) {
        loadedProducts = await getProducts();
        console.log(
          "ðŸ“¦ Loaded",
          loadedProducts.length,
          "products from IndexedDB"
        );
      }

      // If still no products, use defaults
      if (loadedProducts.length === 0) {
        await saveProducts(DEFAULT_PRODUCTS);
        loadedProducts = DEFAULT_PRODUCTS;
        console.log("ðŸŽ¯ Using default products");

        // Sync default products to Google Sheets for new users
        if (storedProductsSheetId) {
          try {
            console.log("ðŸ“¤ Syncing default products to Google Sheets...");
            const syncResponse = await fetch("/api/sheets/sync-products", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                productsSheetId: storedProductsSheetId,
                products: DEFAULT_PRODUCTS,
              }),
            });

            if (syncResponse.ok) {
              console.log("âœ… Default products synced to Google Sheets");
            } else {
              console.error("âŒ Failed to sync default products");
            }
          } catch (error) {
            console.error("âŒ Error syncing default products:", error);
          }
        }
      }

      // Detect if products actually changed
      const hasProductsChanged = detectProductChanges(
        currentProducts,
        loadedProducts
      );

      setProducts(loadedProducts);
      setLoadedFromSheets(productsLoadedFromSheets);
      setProductsChanged(hasProductsChanged);

      // Load category order from settings
      if (storedSalesSheetId) {
        try {
          const settingsResponse = await fetch("/api/sheets/settings/load", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ spreadsheetId: storedSalesSheetId }),
          });

          if (settingsResponse.ok) {
            const settingsData = await settingsResponse.json();
            if (
              settingsData.categories &&
              Array.isArray(settingsData.categories)
            ) {
              setCategoryOrder(settingsData.categories);
              console.log("âœ… Loaded category order:", settingsData.categories);
            }
          }
        } catch (error) {
          console.error("âŒ Failed to load category order:", error);
        }
      }

      setIsInitialized(true);
    } catch (error) {
      console.error("âŒ Failed to initialize app:", error);
      // Set initialized anyway to prevent infinite loading
      // User can retry from settings or debug page
      setIsInitialized(true);
      setToast({
        message:
          "âš ï¸ Error during initialization. Some features may not work. Try refreshing or check /debug",
        type: "error",
      });
    }
  };

  const updateSyncStatus = async () => {
    const unsyncedSales = await getUnsyncedSales();
    const allSales = await getSales();
    setSyncStatus((prev) => ({
      ...prev,
      pendingSales: unsyncedSales.length,
      totalSales: allSales.length,
    }));
  };

  const handleCompleteSale = async (
    items: CartItem[],
    total: number,
    actualAmount: number,
    paymentMethod: PaymentMethod,
    discount?: number
  ) => {
    const sale: Sale = {
      id: `sale-${Date.now()}`,
      timestamp: new Date().toISOString(),
      items: items.map((item) => ({
        productId: item.product.id,
        productName: item.product.name,
        quantity: item.quantity,
        price: item.product.price,
        size: item.size,
      })),
      total,
      actualAmount,
      discount,
      paymentMethod,
      synced: false,
      isHookup: discount !== undefined && discount > 0, // For backward compatibility
    };

    await saveSale(sale);
    await updateSyncStatus();

    if (navigator.onLine) {
      syncSales();
    }
  };

  const syncSales = async () => {
    if (syncStatus.isSyncing) return;

    setSyncStatus((prev) => ({ ...prev, isSyncing: true }));

    try {
      const unsyncedSales = await getUnsyncedSales();
      const salesSheetId = localStorage.getItem("salesSheetId");

      if (unsyncedSales.length > 0 && salesSheetId) {
        const response = await fetch("/api/sheets/sync-sales", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sales: unsyncedSales, salesSheetId }),
        });

        if (response.ok) {
          for (const sale of unsyncedSales) {
            await markSaleAsSynced(sale.id);
          }

          // Delete synced sales to keep local storage clean
          const deletedCount = await deleteSyncedSales();
          console.log(
            `ðŸ—‘ï¸ Cleaned up ${deletedCount} synced sales from local storage`
          );

          const allSales = await getSales();
          setSyncStatus({
            lastSyncTime: new Date().toISOString(),
            pendingSales: 0,
            totalSales: allSales.length,
            isSyncing: false,
            pendingProductSync: false,
          });
        }
      } else {
        setSyncStatus((prev) => ({ ...prev, isSyncing: false }));
      }
    } catch (error) {
      console.error("Sync failed:", error);
      setSyncStatus((prev) => ({ ...prev, isSyncing: false }));
    }
  };

  const handleAddProduct = async (product: Product) => {
    await addProductToDB(product);
    const updatedProducts = await getProducts();
    setProducts(updatedProducts);

    // Mark products as needing sync and try to sync immediately
    setSyncStatus((prev) => ({ ...prev, pendingProductSync: true }));
    await syncProductsToSheet();
  };

  const handleUpdateProduct = async (product: Product) => {
    await addProductToDB(product); // addProductToDB uses put() which updates if ID exists
    const updatedProducts = await getProducts();
    setProducts(updatedProducts);

    // Mark products as needing sync and try to sync immediately
    setSyncStatus((prev) => ({ ...prev, pendingProductSync: true }));
    await syncProductsToSheet();
  };

  const handleDeleteProduct = async (id: string) => {
    if (confirm("Are you sure you want to delete this product?")) {
      await deleteProductFromDB(id);
      const updatedProducts = await getProducts();
      setProducts(updatedProducts);

      // Mark products as needing sync and try to sync immediately
      setSyncStatus((prev) => ({ ...prev, pendingProductSync: true }));
      await syncProductsToSheet();
    }
  };

  const syncProductsToSheet = async () => {
    try {
      const productsSheetId = localStorage.getItem("productsSheetId");

      if (!productsSheetId) {
        console.warn(
          "Products sheet not initialized - will sync when available"
        );
        return;
      }

      // Get latest products from IndexedDB
      const currentProducts = await getProducts();

      const response = await fetch("/api/sheets/sync-products", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ products: currentProducts, productsSheetId }),
      });

      if (!response.ok) {
        throw new Error("Failed to sync");
      }

      console.log("âœ… Products synced to Google Sheets");
      setSyncStatus((prev) => ({ ...prev, pendingProductSync: false }));
    } catch (error) {
      console.error("Failed to sync products:", error);
      // Keep pendingProductSync true so it retries when online
      setSyncStatus((prev) => ({ ...prev, pendingProductSync: true }));
    }
  };

  if (isInitializingSheets) {
    return (
      <div className="flex items-center justify-center h-screen bg-zinc-900">
        <div className="text-center max-w-md">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-red-500 mx-auto mb-4"></div>
          <p className="text-white text-lg font-semibold mb-2">
            Setting up your Google Sheets...
          </p>
          <p className="text-zinc-400 text-sm">
            Creating Products and Sales sheets in your Google Drive
          </p>
        </div>
      </div>
    );
  }

  if (!isInitialized) {
    return (
      <div className="flex items-center justify-center h-screen bg-zinc-900">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-red-500 mx-auto mb-4"></div>
          <p className="text-zinc-400">Loading...</p>
        </div>
      </div>
    );
  }

  // Show loading state while checking authentication
  if (status === "loading" || status === "unauthenticated") {
    return (
      <div className="min-h-screen bg-zinc-900 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-red-500 mx-auto mb-4"></div>
          <p className="text-zinc-400">
            {status === "loading" ? "Loading..." : "Redirecting to sign in..."}
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-zinc-900">
      <header className="bg-black border-b border-zinc-700 p-3 sm:p-4">
        <div className="flex items-center justify-between">
          <h1 className="text-xl sm:text-2xl font-bold text-white">
            ðŸŽ¸ Merch Table
          </h1>
          <div className="flex items-center gap-2 sm:gap-4">
            <div className="text-right hidden sm:block">
              <p className="text-sm text-zinc-400">Signed in as</p>
              <p className="text-sm font-medium text-white">
                {session?.user?.email}
              </p>
            </div>
            <button
              onClick={() => setActiveTab("settings")}
              className={`p-2 sm:px-4 sm:py-2 rounded border transition-all ${
                activeTab === "settings"
                  ? "bg-zinc-700 border-zinc-600 text-white"
                  : "bg-zinc-800 hover:bg-zinc-700 text-zinc-300 hover:text-white border-zinc-700"
              }`}
              title="Settings"
            >
              <Cog6ToothIcon className="w-5 h-5" />
            </button>
            <button
              onClick={() => signOut()}
              className="p-2 sm:px-4 sm:py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 hover:text-white rounded border border-zinc-700 text-sm transition-all flex items-center gap-2"
              title="Sign Out"
            >
              <ArrowRightOnRectangleIcon className="w-5 h-5" />
              <span className="hidden sm:inline">Sign Out</span>
            </button>
          </div>
        </div>
      </header>

      <SyncStatusBar status={syncStatus} onSync={syncSales} />

      <nav className="bg-zinc-900 border-b border-zinc-700">
        <div className="flex">
          <button
            onClick={() => setActiveTab("pos")}
            className={`flex-1 py-3 sm:py-4 px-2 sm:px-6 font-medium flex items-center justify-center gap-2 touch-manipulation ${
              activeTab === "pos"
                ? "border-b-2 border-red-500 text-red-400"
                : "text-zinc-400 hover:text-zinc-200"
            }`}
          >
            <ShoppingBagIcon className="w-5 h-5 flex-shrink-0" />
            <span className="hidden sm:inline">Point of Sale</span>
          </button>
          <button
            onClick={() => setActiveTab("setup")}
            className={`flex-1 py-3 sm:py-4 px-2 sm:px-6 font-medium flex items-center justify-center gap-2 touch-manipulation ${
              activeTab === "setup"
                ? "border-b-2 border-red-500 text-red-400"
                : "text-zinc-400 hover:text-zinc-200"
            }`}
          >
            <ArchiveBoxIcon className="w-5 h-5 flex-shrink-0" />
            <span className="hidden sm:inline">Inventory</span>
          </button>
          <button
            onClick={() => setActiveTab("analytics")}
            className={`flex-1 py-3 sm:py-4 px-2 sm:px-6 font-medium flex items-center justify-center gap-2 touch-manipulation ${
              activeTab === "analytics"
                ? "border-b-2 border-red-500 text-red-400"
                : "text-zinc-400 hover:text-zinc-200"
            }`}
          >
            <ChartBarIcon className="w-5 h-5 flex-shrink-0" />
            <span className="hidden sm:inline">Analytics</span>
          </button>
        </div>
      </nav>

      <main className="flex-1 bg-zinc-900">
        {activeTab === "pos" && (
          <POSInterface
            products={products}
            categoryOrder={categoryOrder}
            onCompleteSale={handleCompleteSale}
            onUpdateProduct={handleUpdateProduct}
          />
        )}
        {activeTab === "setup" && (
          <ProductManager
            products={products}
            onAddProduct={handleAddProduct}
            onUpdateProduct={handleUpdateProduct}
            onDeleteProduct={handleDeleteProduct}
          />
        )}
        {activeTab === "analytics" && <Analytics />}
        {activeTab === "settings" && <Settings />}
      </main>

      <OfflineIndicator />

      {/* Toast Notification */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          onClose={() => setToast(null)}
        />
      )}
    </div>
  );
}
